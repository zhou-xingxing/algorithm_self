# 排序算法

## 关注点

- 执行效率
	- 最好、最坏、平均
- 内存消耗
- 算法稳定性

![img](https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg)

## 基于比较的排序算法

### 冒泡排序

- 优化

	当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

- 原地排序、稳定算法

- 带优化的时间复杂度

	最好：O(n)	最坏：O(n^2^)	平均：O(n^2^)

### 插入排序

- 原地排序、稳定算法

- 时间复杂度

	最好：O(n)	最坏：O(n^2^)	平均：O(n^2^)

插入排序一般比冒泡排序更常见，因为交换操作比移动操作更复杂

### 选择排序

- 原地排序、==非稳定算法==

	5,8,5,2,9 ----> 9,8,5,2,5

- 时间复杂度

	最好：O(n^2^)	最坏：O(n^2^)	平均：O(n^2^)

### 归并排序

- 非原地排序、稳定算法

	空间复杂度：O(n)

- 时间复杂度

	O(nlogn)

### 快速排序

- 原地排序、非稳定算法

	1,1,1,1,1,1

- 时间复杂度

	最好：O(nlogn)	最坏：O(n^2^)	平均：O(nlogn)
	
- 优化

	三数取中、手动模拟递归，数据量小时先使用归并排序，快排过程中元素小于4个时，改为插入排序（可以利用哨兵优化）

## 非比较排序

桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。

基数排序要求数据可以划分成高低位，位之间有递进关系。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。

![img](https://static001.geekbang.org/resource/image/df/0c/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg)

